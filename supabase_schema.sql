-- Enable the pg_trgm extension for faster text search (optional but recommended)
create extension if not exists pg_trgm;

-- 1. Location Search Cache Table
create table if not exists location_search_cache (
  id bigint generated by default as identity primary key,
  query text not null,
  results jsonb not null,
  hit_count integer default 0,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  
  -- Add constraint to ensure unique queries (normalized)
  constraint location_search_cache_query_key unique (query)
);

-- Create index for faster lookups
create index if not exists location_search_cache_query_idx on location_search_cache (query);

-- 2. Persona Image Cache Table
create table if not exists persona_image_cache (
  id bigint generated by default as identity primary key,
  cache_key text not null,
  image_url text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  
  -- Add constraint to ensure unique cache keys
  constraint persona_image_cache_key_key unique (cache_key)
);

-- Create index for faster lookups
create index if not exists persona_image_cache_key_idx on persona_image_cache (cache_key);

-- 3. API Usage Logs (for monitoring)
create table if not exists api_usage_logs (
  id bigint generated by default as identity primary key,
  call_type text not null,
  estimated_cost numeric,
  provider text, -- 'Gemini', 'Tavily', etc.
  api_key_masked text, -- '...Geb1'
  total_cost numeric, -- Cumulative total at this point
  timestamp timestamp with time zone default timezone('utc'::text, now()) not null
);

-- RLS Policies (Optional - adjust based on your security needs)
alter table location_search_cache enable row level security;
alter table persona_image_cache enable row level security;
alter table api_usage_logs enable row level security;

-- Allow read access to everyone (for cache)
create policy "Allow public read access" on location_search_cache for select using (true);
create policy "Allow public read access" on persona_image_cache for select using (true);

-- Allow insert access to authenticated users (or anon if using anon key)
create policy "Allow insert access" on location_search_cache for insert with check (true);
create policy "Allow insert access" on persona_image_cache for insert with check (true);
create policy "Allow insert access" on api_usage_logs for insert with check (true);

-- Allow update access (for hit_count)
create policy "Allow update access" on location_search_cache for update using (true);

-- 4. Real User Profiles (v2 - Bulletproof)
-- Using fully qualified names and aliases to prevent "uuid = bigint" ambiguity
drop trigger if exists on_auth_user_created on auth.users;
drop function if exists public.handle_new_user();
drop table if exists public.app_connections_v2 cascade;
drop table if exists public.app_profiles_v2 cascade;

-- Create Profiles v2
create table public.app_profiles_v2 (
  id uuid references auth.users on delete cascade primary key,
  username text unique,
  full_name text,
  bio text,
  occupation text,
  location text,
  age integer,
  avatar_url text,
  avatar_source text check (avatar_source in ('upload', 'library')),
  is_private boolean default false,
  is_verified_human boolean default true,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create Connections v2
create table public.app_connections_v2 (
  id bigint generated by default as identity primary key,
  requester_id uuid references public.app_profiles_v2(id) on delete cascade not null,
  target_id uuid references public.app_profiles_v2(id) on delete cascade not null,
  status text check (status in ('pending', 'accepted')) default 'pending',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(requester_id, target_id)
);

-- RLS for Profiles
alter table public.app_profiles_v2 enable row level security;

-- Public Read
create policy "Public profiles are viewable by everyone" 
  on public.app_profiles_v2 for select 
  using ( is_private = false );

-- Private Read (The problematic one - Fixed with Aliases)
create policy "Private profiles are viewable by connections" 
  on public.app_profiles_v2 for select 
  using (
    is_private = true and (
      auth.uid()::uuid = app_profiles_v2.id or
      exists (
        select 1 from public.app_connections_v2 c 
        where (c.requester_id = auth.uid()::uuid and c.target_id = app_profiles_v2.id and c.status = 'accepted')
           or (c.requester_id = app_profiles_v2.id and c.target_id = auth.uid()::uuid and c.status = 'accepted')
      )
    )
  );

-- Update Own Profile
create policy "Users can update own profile" 
  on public.app_profiles_v2 for update 
  using ( auth.uid()::uuid = id );

-- Insert Own Profile
create policy "Users can insert own profile" 
  on public.app_profiles_v2 for insert 
  with check ( auth.uid()::uuid = id );

-- RLS for Connections
alter table public.app_connections_v2 enable row level security;

create policy "Users can view their own connections"
  on public.app_connections_v2 for select
  using ( auth.uid()::uuid = requester_id or auth.uid()::uuid = target_id );

create policy "Users can create connection requests"
  on public.app_connections_v2 for insert
  with check ( auth.uid()::uuid = requester_id );

create policy "Users can update connection status"
  on public.app_connections_v2 for update
  using ( auth.uid()::uuid = target_id );

-- Trigger
create or replace function public.handle_new_user() 
returns trigger as $$
begin
  insert into public.app_profiles_v2 (id, full_name, avatar_url, is_private, is_verified_human)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url', false, true);
  return new;
end;
$$ language plpgsql security definer;

-- Trigger setup
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
